# AUTOGENERATED! DO NOT EDIT! File to edit: ../notebooks/api/06_pypose.ipynb.

# %% auto 0
__all__ = ['convert']

# %% ../notebooks/api/06_pypose.ipynb 3
import torch
import pypose as pp

# %% ../notebooks/api/06_pypose.ipynb 4
def convert(*args, parameterization, convention=None, **kwargs) -> pp.SE3:
    if parameterization == "euler_angles" and convention is None:
        raise ValueError(
            "convention for Euler angles must be specified as a 3 letter combination of [X, Y, Z]"
        )

    if parameterization == "axis_angle":
        rotation, translation = args
        quaternion = pp.so3(rotation).Exp().tensor()
        return convert(quaternion, translation, parameterization="quaternion")
    elif parameterization == "euler_angles":
        rotation, translation = args
        rotmat = euler_angles_to_matrix(rotation, convention)
        matrix = torch.concat([rotmat, translation.unsqueeze(-1)], axis=-1)
        return convert(matrix, parameterization="matrix", check=False)
    elif parameterization == "matrix":
        return pp.from_matrix(*args, ltype=pp.SE3_type, **kwargs)
    elif parameterization == "quaternion":
        rotation, translation = args
        return pp.SE3(torch.concat([translation, rotation], axis=-1))
    elif parameterization == "quaternion_adjugate":
        rotation, translation = args
        quaternion = quaternion_adjugate_to_quaternion(rotation)
        return convert(quaternion, translation, parameterization="quaternion")
    elif parameterization == "rotation_6d":
        rotation, translation = args
        rotmat = rotation_6d_to_matrix(rotation)
        matrix = torch.concat([rotmat, translation.unsqueeze(-1)], axis=-1)
        return convert(matrix, parameterization="matrix", check=False)
    elif parameterization in ["rotation_10d"]:
        rotation, translation = args
        quaternion = rotation_10d_to_quaternion(rotation)
        return convert(quaternion, translation, parameterization="quaternion")
    elif parameterization == "se3":
        rotation, translation = args
        return pp.se3(torch.concat([translation, rotation], axis=-1)).Exp()
    elif parameterization == "SE3":
        return args[0]
    else:
        raise ValueError

# %% ../notebooks/api/06_pypose.ipynb 5
def rotation_6d_to_matrix(d6: torch.Tensor) -> torch.Tensor:
    """Source: http://arxiv.org/abs/1812.07035"""
    a1, a2 = d6[..., :3], d6[..., 3:]
    b1 = F.normalize(a1, dim=-1)
    b2 = a2 - (b1 * a2).sum(-1, keepdim=True) * b1
    b2 = F.normalize(b2, dim=-1)
    b3 = torch.cross(b1, b2, dim=-1)
    return torch.stack((b1, b2, b3), dim=-2)


def rotation_10d_to_quaternion(rotation: torch.Tensor) -> torch.Tensor:
    """
    Convert a 10-vector into a symmetric matrix, whose eigenvector corresponding
    to the eigenvalue of minimum modulus is the resulting quaternion.

    Source: https://arxiv.org/abs/2006.01031
    """
    A = _10vec_to_4x4symmetric(rotation)  # A is a symmetric data matrix
    return torch.linalg.eigh(A).eigenvectors[..., 0]


def quaternion_adjugate_to_quaternion(rotation: torch.Tensor) -> torch.Tensor:
    """
    Convert a 10-vector in the quaternion adjugate, a symmetric matrix whose
    eigenvector corresponding to the eigenvalue of maximum modulus is the
    (unnormalized) quaternion. Uses a fast method to solve for the eigenvector
    without explicity computing the eigendecomposition.

    Source: https://arxiv.org/abs/2205.09116
    """
    A = _10vec_to_4x4symmetric(rotation)  # A is the quaternion adjugate
    norms = A.norm(dim=1).amax(dim=1, keepdim=True)
    max_eigenvectors = torch.argmax(A.norm(dim=1), dim=1)
    return A[range(len(A)), max_eigenvectors] / norms


def _10vec_to_4x4symmetric(vec):
    """Convert a 10-vector to a symmetric 4x4 matrix."""
    b = len(vec)
    A = torch.zeros(b, 4, 4, device=vec.device)
    idx, jdx = torch.triu_indices(4, 4)
    A[..., idx, jdx] = vec
    A[..., jdx, idx] = vec
    return A

# %% ../notebooks/api/06_pypose.ipynb 6
def euler_angles_to_matrix(euler_angles: torch.Tensor, convention: str) -> torch.Tensor:
    if euler_angles.dim() == 0 or euler_angles.shape[-1] != 3:
        raise ValueError("Invalid input euler angles.")
    if len(convention) != 3:
        raise ValueError("Convention must have 3 letters.")
    if convention[1] in (convention[0], convention[2]):
        raise ValueError(f"Invalid convention {convention}.")
    for letter in convention:
        if letter not in ("X", "Y", "Z"):
            raise ValueError(f"Invalid letter {letter} in convention string.")
    matrices = [
        _axis_angle_rotation(c, e)
        for c, e in zip(convention, torch.unbind(euler_angles, -1))
    ]
    return torch.matmul(torch.matmul(matrices[0], matrices[1]), matrices[2])


def _axis_angle_rotation(axis: str, angle: torch.Tensor) -> torch.Tensor:
    cos = torch.cos(angle)
    sin = torch.sin(angle)
    one = torch.ones_like(angle)
    zero = torch.zeros_like(angle)

    if axis == "X":
        R_flat = (one, zero, zero, zero, cos, -sin, zero, sin, cos)
    elif axis == "Y":
        R_flat = (cos, zero, sin, zero, one, zero, -sin, zero, cos)
    elif axis == "Z":
        R_flat = (cos, -sin, zero, sin, cos, zero, zero, zero, one)
    else:
        raise ValueError("letter must be either X, Y or Z.")

    return torch.stack(R_flat, -1).reshape(angle.shape + (3, 3))
